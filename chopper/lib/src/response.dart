import 'dart:typed_data';

import 'package:http/http.dart' as http;
import 'package:meta/meta.dart';

/// Wrapper arround [http.BaseResponse]
///
/// Return by every function generated by Chopper.
///
/// Example:
/// ```dart
/// @Get(path: '/something')
/// Future<Response> fetchSomething();
/// ```
@immutable
class Response<BodyType> {
  /// Base response return by `package:http`
  final http.BaseResponse base;

  /// Body of response converted by Chopper
  /// see [Converter] for more infos
  ///
  /// Can be null if [isSuccessful] is not true
  /// Use [error] to get error body
  final BodyType body;

  /// Body of response if [isSuccessful] is false
  final Object error;

  Response(this.base, this.body, {this.error});

  @Deprecated('Prefer copyWith method')
  Response<NewBodyType> replace<NewBodyType>({
    http.BaseResponse base,
    NewBodyType body,
    Object bodyError,
  }) =>
      copyWith<NewBodyType>(
        base: base,
        body: body,
        bodyError: bodyError,
      );

  /// Make a copy of the current response
  /// And replace with given values
  Response<NewBodyType> copyWith<NewBodyType>({
    http.BaseResponse base,
    NewBodyType body,
    Object bodyError,
  }) =>
      Response<NewBodyType>(
        base ?? this.base,
        body ?? (this.body as NewBodyType),
        error: bodyError ?? error,
      );

  /// HTTP status code of the response
  int get statusCode => base.statusCode;

  /// true if status code is >= 200 && <3
  /// if false, [error] will contains the response
  bool get isSuccessful => statusCode >= 200 && statusCode < 300;

  /// HTTP headers of the response
  Map<String, String> get headers => base.headers;

  /// Return body as bytes ([Uint8List]) if available
  Uint8List get bodyBytes =>
      base is http.Response ? (base as http.Response).bodyBytes : null;

  /// Return body as [String] if available
  String get bodyString =>
      base is http.Response ? (base as http.Response).body : null;
}
